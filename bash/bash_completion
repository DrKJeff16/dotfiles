# vim:ft=bash:

#
# ~/.bash_completion
#

# shellcheck disable=SC1001,SC2207

__up_complete() {
    if [[ ${#COMP_WORDS[@]} -ne 2 ]]; then
        return
    fi

    local COUNT
    if [[ "$PWD" != "/c" ]] && [[ "$PWD" != "/d" ]] && [[ "$PWD" != "/" ]]; then
        COUNT=$(echo "$PWD" | awk -F\/ '{print NF-1}')

        COMPREPLY=($(compgen -W "$(seq 2 $((COUNT)))" -- "${COMP_WORDS[COMP_CWORD]}"))
        return
    fi
}
complete -F __up_complete up

__cc_select_complete() {
    local OPTS="-h -help"
    local LOPTS="--help"
    local LOPTIONS="gcc g++ gnu clang clang++ llvm cc c++"
    local UOPTIONS="GCC G++ GNU CLANG CLANG++ LLVM CC C++"

    if [[ "${COMP_WORDS[COMP_CWORD]}" =~ ^--.*$ ]]; then
        COMPREPLY=($(compgen -W "${LOPTS}" -- "${COMP_WORDS[COMP_CWORD]}"))
    elif [[ "${COMP_WORDS[COMP_CWORD]}" =~ ^-.*$ ]]; then
        COMPREPLY=($(compgen -W "${OPTS}" -- "${COMP_WORDS[COMP_CWORD]}"))
    elif [[ "${COMP_WORDS[COMP_CWORD]}" =~ ^[a-z]*$ ]]; then
        COMPREPLY=($(compgen -W "${LOPTIONS}" -- "${COMP_WORDS[COMP_CWORD]}"))
    elif [[ "${COMP_WORDS[COMP_CWORD]}" =~ ^[A-Z]*$ ]]; then
        COMPREPLY=($(compgen -W "${UOPTIONS}" -- "${COMP_WORDS[COMP_CWORD]}"))
    fi
}
complete -F __cc_select_complete select_cc

__complete_edenv() {
    if [[ ${#COMP_WORDS[@]} -ne 2 ]] || [[ -z ${ENVD+X} ]] || ! [[ -d "$ENVD" ]]; then
        return
    fi

    local OPTS

    for F in $(find "$ENVD" -maxdepth 1 -type f | sort); do
        EFILE="$(basename "$F")"

        if [[ -z "$OPTS" ]]; then
            OPTS="$EFILE"
        else
            OPTS="$OPTS $EFILE"
        fi
    done

    COMPREPLY=($(compgen -W "$OPTS" -- "${COMP_WORDS[COMP_CWORD]}"))
}
complete -F __complete_edenv edenv

__complete_gobld() {
    if [[ ${#COMP_WORDS[@]} -lt 2 ]] || [[ -z ${BUILDD+X} ]] || ! [[ -d "$BUILDD" ]]; then
        return
    fi

    local TARGET="$BUILDD"

    if [[ "${COMP_WORDS[COMP_CWORD - 1]}" != "gobld" ]]; then
        local I=1
        local SFX=""

        while [[ "${COMP_WORDS[COMP_CWORD - I]}" != "gobld" ]] && [[ $COMP_CWORD -gt $I ]]; do
            if [[ -z "$SFX" ]]; then
                SFX="${COMP_WORDS[COMP_CWORD - I]}"
            else
                SFX="${COMP_WORDS[COMP_CWORD - I]}/${SFX}"
            fi

            I=$(( I + 1 ))
        done

        TARGET="$TARGET/$SFX"
    fi

    if ! [[ -d "$TARGET" ]]; then
        return
    fi

    local OPTS

    for D in $(find "$TARGET" -maxdepth 1 -type d | tail -n +2 | sort); do
        DIR="$(basename "$D")"

        if [[ $DIR =~ ^(\.git(hub)?|src|pkg)$ ]]; then
            return
        fi

        if [[ -z "$OPTS" ]]; then
            OPTS="$DIR"
        else
            OPTS="$OPTS $DIR"
        fi
    done

    COMPREPLY=($(compgen -W "$OPTS" -- "${COMP_WORDS[COMP_CWORD]}"))
}
complete -F __complete_gobld gobld

__complete_goproj() {
    local TARGET="$HOME/Projects"

    if [[ ${#COMP_WORDS[@]} -lt 2 ]] || ! [[ -d "$TARGET" ]] ; then
        return
    fi

    if [[ "${COMP_WORDS[COMP_CWORD - 1]}" != "goproj" ]]; then
        local I=1
        local SFX=""

        while [[ "${COMP_WORDS[COMP_CWORD - I]}" != "goproj" ]] && [[ $COMP_CWORD -gt $I ]]; do
            if [[ -z "$SFX" ]]; then
                SFX="${COMP_WORDS[COMP_CWORD - I]}"
            else
                SFX="${COMP_WORDS[COMP_CWORD - I]}/${SFX}"
            fi

            I=$(( I + 1 ))
        done

        TARGET="$TARGET/$SFX"
    fi

    if ! [[ -d "$TARGET" ]]; then
        return
    fi

    local OPTS

    for D in $(find "$TARGET" -maxdepth 1 -type d | tail -n +2 | sort); do
        DIR="$(basename "$D")"

        if [[ $DIR =~ ^(\.git(hub)?|lua)$ ]]; then
            return
        fi

        if [[ -z "$OPTS" ]]; then
            OPTS="$DIR"
        else
            OPTS="$OPTS $DIR"
        fi
    done

    COMPREPLY=($(compgen -W "$OPTS" -- "${COMP_WORDS[COMP_CWORD]}"))
}
complete -F __complete_goproj goproj

__complete_gocfg() {
    local TARGET="$HOME/.config"

    if [[ ${#COMP_WORDS[@]} -lt 2 ]] || ! [[ -d "$TARGET" ]] ; then
        return
    fi

    if [[ "${COMP_WORDS[COMP_CWORD - 1]}" != "gocfg" ]]; then
        local I=1
        local SFX=""

        while [[ "${COMP_WORDS[COMP_CWORD - I]}" != "gocfg" ]] && [[ $COMP_CWORD -gt $I ]]; do
            if [[ -z "$SFX" ]]; then
                SFX="${COMP_WORDS[COMP_CWORD - I]}"
            else
                SFX="${COMP_WORDS[COMP_CWORD - I]}/${SFX}"
            fi

            I=$(( I + 1 ))
        done

        TARGET="$TARGET/$SFX"
    fi

    if ! [[ -d "$TARGET" ]]; then
        return
    fi

    local OPTS

    for D in $(find "$TARGET" -maxdepth 1 -type d | tail -n +2 | sort); do
        DIR="$(basename "$D")"

        if [[ $DIR =~ ^\.git(hub)?$ ]]; then
            return
        fi

        if [[ -z "$OPTS" ]]; then
            OPTS="$DIR"
        else
            OPTS="$OPTS $DIR"
        fi
    done

    COMPREPLY=($(compgen -W "$OPTS" -- "${COMP_WORDS[COMP_CWORD]}"))
}
complete -F __complete_gocfg gocfg

__complete_godocs() {
    local TARGET="$HOME/Documents"

    if [[ ${#COMP_WORDS[@]} -lt 2 ]] || ! [[ -d "$TARGET" ]] ; then
        return
    fi

    if [[ "${COMP_WORDS[COMP_CWORD - 1]}" != "godocs" ]]; then
        local I=1
        local SFX=""

        while [[ "${COMP_WORDS[COMP_CWORD - I]}" != "godocs" ]] && [[ $COMP_CWORD -gt $I ]]; do
            if [[ -z "$SFX" ]]; then
                SFX="${COMP_WORDS[COMP_CWORD - I]}"
            else
                SFX="${COMP_WORDS[COMP_CWORD - I]}/${SFX}"
            fi

            I=$(( I + 1 ))
        done

        TARGET="$TARGET/$SFX"
    fi

    if ! [[ -d "$TARGET" ]]; then
        return
    fi

    local OPTS

    for D in $(find "$TARGET" -maxdepth 1 -type d | tail -n +2 | sort); do
        DIR="$(basename "$D")"

        if [[ $DIR =~ ^\.git(hub)?$ ]]; then
            return
        fi

        if [[ -z "$OPTS" ]]; then
            OPTS="$DIR"
        else
            OPTS="$OPTS $DIR"
        fi
    done

    COMPREPLY=($(compgen -W "$OPTS" -- "${COMP_WORDS[COMP_CWORD]}"))
}
complete -F __complete_godocs godocs

complete -A directory mkdir
